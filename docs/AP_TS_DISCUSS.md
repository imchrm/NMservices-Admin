Вот скорректированное Техническое Задание (версия 1.1), в которое интегрированы важные технические нюансы (обработка ошибок, фильтрация, массовые операции).

Ниже, после текста ТЗ, вынесен список вопросов, которые требуют вашего уточнения для финализации задачи.

---

# Техническое задание: Admin Panel (React Admin)

**Тип проекта:** Frontend приложение (Single Page Application)
**Версия:** 1.1 (Обновленная)

## 1. Общее описание
Разработка веб-интерфейса (административной панели) для управления пользователями и заказами. Приложение взаимодействует с существующим REST API, работает полностью на стороне клиента (Client-side), не требует серверного рендеринга (SSR) и собирается в статические файлы.

## 2. Технический стек

### Core
- **React** 18.2+
- **TypeScript** 5.3+
- **Vite** 5.0+ (Сборщик)

### Framework
- **react-admin** 4.16+
- **ra-data-simple-rest** (Базовый провайдер с кастомизацией)

### UI/UX
- **Material-UI (MUI)** 5.15+
- **@mui/icons-material**

## 3. Требования к Backend API (Контракт)

Frontend-приложение ожидает следующего поведения от API:

*   **Base URL:** Конфигурируется через `.env`.
*   **Auth:** Заголовок `X-Admin-Key` в каждом запросе.
*   **Pagination:** Параметры `skip` (смещение) и `limit` (количество).
*   **Filtering:** "Плоские" GET-параметры (например, `?status=pending`, а не JSON-объект).
*   **Errors:** В случае ошибки валидации (422) API возвращает детализацию по полям.
*   **CORS:** Сервер должен разрешать `OPTIONS` запросы, заголовок `X-Admin-Key` и методы `PATCH`, `DELETE` с домена админки.

## 4. Структура проекта

Стандартная структура React-приложения на Vite:

```
admin-panel/
├── src/
│   ├── providers/
│   │   ├── authProvider.ts         # Логика входа/выхода
│   │   └── dataProvider.ts         # СЛОЖНАЯ ЛОГИКА (Адаптер API)
│   ├── users/                      # Ресурсы пользователей
│   ├── orders/                     # Ресурсы заказов
│   ├── types/                      # TypeScript интерфейсы
│   └── App.tsx                     # Конфигурация
├── .env                            # Переменные окружения
└── vite.config.ts
```

## 5. Реализация Data Provider (`src/providers/dataProvider.ts`)

Это критически важный модуль. Необходимо написать обертку над стандартным REST-провайдером, реализующую следующую логику:

### 5.1. Аутентификация и Заголовки
- Перехватывать все запросы `fetch` и добавлять заголовок `X-Admin-Key` (значение берется из `localStorage`).

### 5.2. Пагинация и Сортировка
- Конвертация параметров React Admin (`page`, `perPage`) в параметры API (`skip`, `limit`).
- *Примечание:* Если API не поддерживает сортировку, параметры `sort` и `order` игнорируются при запросе.

### 5.3. Фильтрация
- Преобразование объекта фильтра `{ status: "new" }` в query-строку `?status=new`.

### 5.4. Обработка ошибок (Error Mapping)
- Перехват ошибок со статусом `422 Unprocessable Entity`.
- Парсинг ответа API и преобразование его в формат, понятный `react-admin` для подсветки полей в формах:
  *От Backend:* `[{ loc: ["body", "phone"], msg: "Invalid format" }]`
  *В Frontend:* `throw { status: 422, message: "Validation error", errors: { phone: "Invalid format" } }`

### 5.5. Массовые операции (Bulk Actions)
- **DeleteMany:** Так как API не имеет эндпоинта для массового удаления, провайдер должен:
  1. Принять массив ID.
  2. Выполнить серию параллельных запросов `DELETE` (через `Promise.all`).
  3. Вернуть агрегированный результат.

### 5.6. Метод Update
- Использовать HTTP метод `PATCH`.
- Отправлять JSON-тело запроса.

## 6. Функциональные требования к интерфейсу

### 6.1. Аутентификация
- **Login Page:** Форма ввода API ключа.
- **Security:** Реализация Content Security Policy (CSP) в заголовках ответа сервера (при деплое) для защиты `localStorage`.

### 6.2. Пользователи (Users)
- **List:** Таблица. Поля: ID, Телефон, Дата регистрации.
  - *Действия:* Просмотр, Удаление.
- **Create:** Валидация телефона (обязательное поле).

### 6.3. Заказы (Orders)
- **List:** Таблица. Поля: ID, Статус (цветной Badge), Сумма, Дата.
  - *Фильтр:* Выпадающий список по статусу.
- **Edit/Show:** Возможность изменить статус заказа и примечание.

## 7. Типизация (TypeScript)

**Файл `src/types/index.ts`:**
```typescript
export interface User {
    id: number;
    phone_number: string;
    created_at: string; // Строка от API
    updated_at: string;
}

export interface Order {
    id: number;
    user_id: number;
    status: string;
    total_amount: number | null;
    notes: string | null;
    created_at: string;
}
```

## 8. Деплой и Окружение

- **Build:** `npm run build` создает папку `dist`.
- **Environment:**
  - `VITE_API_URL`: URL бэкенда.
- **Server config (Nginx/Vercel):**
  - Любой маршрут (кроме ассетов) должен отдавать `index.html` (SPA fallback).

---

# ❓ Вопросы для обсуждения (To Discuss)

Перед началом разработки необходимо прояснить следующие моменты, так как они напрямую влияют на объем работ в `dataProvider`:

1.  **Поддержка сортировки на Backend:**
    Умеет ли текущий API сортировать данные? (Например: `GET /users?sort_by=created_at&order=desc`).
    *   *Если НЕТ:* Нужно отключить возможность кликать по заголовкам столбцов в таблицах React Admin, чтобы интерфейс не вводил в заблуждение.
    *   *Если ДА:* Каков точный синтаксис параметров запроса?

2.  **Формат ошибок валидации:**
    Какой именно JSON возвращает Backend при ошибке 422? (Стандартный Pydantic/FastAPI формат или кастомный?). Это нужно для написания правильного маппера ошибок в п. 5.4.

3.  **Фильтрация заказов:**
    Реализован ли на бэкенде эндпоинт фильтрации заказов? (Например: `GET /admin/orders?status=completed`). Если нет, фильтр в интерфейсе работать не будет.

4.  **Формат дат:**
    В каком формате API отдает дату? (ISO 8601: `2023-10-05T14:48:00.000Z` или что-то другое?). React Admin хорошо работает с ISO, другие форматы потребуют конвертации.

5.  **Безопасность:**
    Согласны ли вы оставить хранение ключа в `localStorage` (проще в реализации, но менее безопасно при XSS) или нужно искать способ проксирования через свой backend (Server-side proxy) для использования `HttpOnly` кук? (В текущей архитектуре "Раздельные проекты" LocalStorage — стандартное решение).